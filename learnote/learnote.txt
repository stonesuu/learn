2016.7.21.001  cp -a:相当于-pdr，-p:连通文件属性一同复制（备份常用），-d:若文件为链接属性，则复制链接属性，-r:递归拷贝，用于拷贝目录，-u:destination比source旧才更新destination,-s:配置软链接，-l:配置硬连接
2016.7.21.002  cat -A:相当于-vET,-b：列出行号，非空白行,-E:断行字符$,-n:列出行号，包含空白行，与-b不同，-T:tab键为^I,-v：显示特殊字符
2016.7.21.003  nl -b a:cat -n，-b t：cat -b
2016.7.21.004  more /字符串：向下搜寻该字符串,:f:立刻显示该文件名和显示行数，b或者[ctrl]-b：往回翻页
2016.7.21.005  python gbk/utf8都是unicode的编码格式，存储的时候，不同的编码格式产生的编码是不同的，用gbk编码的字符用utf8或者asic读取都是乱码，（这里说读取不说是解码，把解码理解为编码与unicode之间的转换）需要先用原来的编码格式解码成unicode,然后再编码成不同的编码格式，如果要换编码格式，肯定需要先解码再编码。目前的理解，print显示，write()文件写入都是使用默认的编码格式来对编码进行显示和写入。如果默认的编码格式于操作的编码的格式不匹配，则会出现问题。另，网上摘录'python的print会对输出的文本做自动的编码转换，而文件对象的write方法就不会做，因此，当一些字符串用print输出正常时，write到文件确不一定和print的一样。print转换的目的编码和环境变量有关，WindowsXP是转换为gbk的。在linux下是按照环境变量来转换的。在linux下使用locale命令就可以看到。'
2016.7.22.001  chattr A:访问时间将不会修改，S：同步写入，a:数据只能增加不能修改，不能删除，只有root设置，c:压缩，d:不会被备份，i:无法增删改连，root设置，s,u:删除是是否保留
2016.7.22.002   suid suid权限仅对二进制程序有效，执行者需x执行权限，本权限在程序过程中有效，执行者具有woner权限。例如-rwsr-xr-x 1 root root 22984 2007-01-07 /usr/bin/passwd,gaolei具有x权限，因此在执行这个程序中，gaolei暂时具备root权限，具备root权限时，就能够修改-r-------- 1 root root 1211 2015-09-25 /etc/shadow这个文件中的内容，suid对shell没有作用。
2016.7.22.003  sgid 除了跟suid类似的情况外，如果将sgid加在目录上，则具备在该目录创建文件的用户创建的文件组属性为这个目录的群组。
2016.7.22.004  sbit 对目录使用，相关人员能够在目录内创建自己的文件，修改／删除自己的文件。这个限制只对该目录的非用户有效，该目录的用户对目录内的内容还是能动的，但是这里跟文件的内容无关，文件内容跟文件本身的权限有关，这是跟文件所在目录的权限有关。牢记对一个目录内的文件进行操作（删除，移动）的权限取决于该用户对该目录的操作权限。
2016.7.22.005 linux which 在PATH上查找相关指令的文件。
2016.7.22.006 linux whereis -b:二进制文件，-m:manual路径下的文件，-s:source来源文件，-u:其他。
2016.7.22.007 linux locate 当无法指定确切文件名时使用 -i:忽略大小写 -r:文件名用正则表达，updatedb:根据/etc/updatedb.conf设定更新/var/lib/mlocate数据库
2016.7.22.008 linux find 依据相关时间查找文件 -mtime\ n:n天之前的一天之内改动的文件,如果n为0，表示从现在往前推24小时内，如果n＝1应该是往前推24－48小时内，-newer\ file:比这个file更新时间靠后的文件，-perm\ [+-]perm:+权限中含有指定权限中的一个就可，-权限包含指定权限，不能少于，理解find / -perm +7000 -exec ls -l {} \;的含义。
2016.7.22.009 linux 总结 进入目录需要x权限，查看目录内容需要r权限，在目录中添加文件需要wx权限，对文件拷贝需要要文件的r权限,cp /dir1/file1 /dir2,dir1需要x权限，file1需要r权限,dir2需要wx权限。
2016.7.22.010 linux 2770目录权限 两个不同的user,属于同一个组，当该目录属于这个组时，这两个用户都能够在这个组内添加文件，由于sgid的设置，用户添加的文件所属组均为目录所属的组，由于文件的默认属性加上umask之后为rw-rw-r--因此两个用户均能够修改对方的文件，其实认为可以再加上sbit，使得无法对对方的文件整体进行删除等操作。
2016.7.22.011 linux 0扇区MBR大小 扇区大小为512字节，MBR大小为446字节，分区表大小为64字节，加起来一共510字节，那MBR和分区表都在0扇区里面，分区表可以包含4条分区信息，那1条分区信息就是16字节，MBR分区表是分区层面的东西，于FS关系不大，超级块是FS层面的东西
2016.7.22.012 linux inode 一个inode的大小为128字节，其中记录一个block的指针大小为4字节，一个inode中有12个直接，一个间接，一个双间接，一个三间接指针，间接指针指向的是专门存放block指针的block,block大小由FS决定，一个inode指针区域大小为60字节，一个inode记录一个文件的所有block指针，由于inode指针区域大小已经确定，当block大小确定的话，文件的最大限制也就确定了，如果block大小为1k的话，一个block存放的指针数量为256个，所以最大文件大小为12＋256＋256＊256＋256＊256＊256（k)=16G
2016.7.22.013 linux 超级块 超级块大小为1k字节，那超级块就不含在MBR中，每个FS有一个超级块，每个FS有多个块组，那就是说不是每个块组都有超级块的，在第一个块组中含有超级块，其余块组中的超级块如果有则是备份
2016.7.22.014 linux FS构成 一个FS分为一个启动扇区和若干块组，一个块组中含有超级块（第一个块组中才有），文件系统描述区域（不知道是否每个都有），block位图，inode位图，inode表，和block区域
2016.7.25.001 linux 权限 一个文件的用户有权力将自身创建的文件组改成另一个组，前提是这个用户属于这个组。只要对一个目录有写操作，并且能进入这个目录，就能在这个目录添加文件，进入这个目录，要求该用户从跟目录开始就具备x权限，写操作只对要操作的这个目录具备w权限。更改一个用户的组只有root才可以吧，不然不科学啊。当用户把一个文件的组属性改成别的组，且这个组有别的用户，那别的用户依据该组的属性具备相应权力。当目录添加sbit时，目录内不同用户只能对自己的文档进行操作，不管这个文档的属性如何，因为操作（移动，删除）只取决于目录的属性。
2016.7.25.002 linux FS构成 查看FS的块组的指令为/sbin/dumpe2fs,FS中的最小单位是block要牢记，不是LBA,LBA和block之间应该是换算的方式，不可能是表记录的方式，FS下层应该是LBA寻址，FS应该具备block于LBA的换算功能。每个块组有32768个块，就是128M。从显示的方式来看，每个块组具备的区域为FS描述区域（描述该组的块区间），block位图，inode位图，inode表，block区域。
2016.7.26.001 linux inode与软硬连接 一个文件由文件名，内容inode，内容block组成，文件名在上层目录的block中，同时存在的是文件名与内容inode的对应关系。对硬连接，在新的目录的内容block下写上一个新的文件名与被连接的内容inode的对应关系，对软连接，在新目录下写上一个快捷方式指向被连接文件的上层目录中的文件名与inode的对应关系的条目。但是硬连接为什么不能连接目录呢，这里不好解释。
2016.7.26.002 linux 指令 du和df du查看文件和目录的大小，df查看分区使用情况
2016.7.26.003 linux ls-d理解 ll查看的第二项指的是该目录内目录的数量，不要忘记还有自身和上层两个隐藏目录。
2016.7.26.004 linux fdisk fdisk解-l查看个分区信息，fdisk加分区则对分区进行格式化，里面有增加分区减少分区的指令，说明这个指令不止是FS层面，fdisk-l中起始记录是以磁柱来确认的cylinder指的是磁柱，sector指的是扇区。鸟哥里说明fdisk针对整个磁盘进行操作，对分区进行操作会出错。
2016.7.26.005 linux mkfs fdisk是分区的指令，分区完毕之后是mkfs,mke2fs,其中mke2fs-i指的是多少字节分配一个inode,文件系统安装安成之后可以fsck
2016.7.26.006 linux fsck -A对/etc/fstab中的内容全部扫描一次，-a自动修复问题扇区,-C，显示进度条,-f强制检查，貌似fsck不会检查没有unclean标志的文件系统（标志从哪来？），-D针对文件系统下的目录进行优化配置？此命令通常在FS出现较大问题，导致Linux进入单人模式进行维护时使用，可能造成部分FS损坏，检查的分区务必卸载！！有问题的数据会放在lost+found文件中
2016.7.26.007 linux 挂载 挂载前需要确认的事情，不要重复挂载不同的挂载点，单一目录不要挂载多个FS，挂载点应该是空目录，如果目录不空，则原内容被隐藏，知道挂载设备卸载。
2016.7.26.008 linux 挂载 mount,文件系统有label名称，-a将/etc/fstab中未挂载的磁盘全部挂载，-l显示挂在信息和label名称，-t选择FS类型，-o权限。几乎所有FS都有超级块，超级块中有文件系统的相关信息，每个FS都需要相应的驱动程序，目录/lib/modules/$(uname -r)/kernal/fs/
2016.7.26.009 linux 挂在 插入U盘等设备时，使用fdisk-l可以查看.根目录无法卸载，如果要修改根目录的权限，使用指令mount -o remount,rw,auto / 
2016.7.27.001 Linux ln ln的软连接为ln-s 源目录或文件 目标快捷方式，软连接可以跨分区，硬连接无法跨分区，每个分区一个FS，每个FS的inode表是不同的，会报错说无效的跨设备连接。mount的方式也是先源后目的，mount--bind将一个目录挂载到另一个目录下，同一个inode,这里是要主义的，硬连接无法连接目录，也无法跨设备，mount--bind是可以的，书上说这种方式跟软连接一样,主义，mount只有root有权限。
2016.7.27.002 linux Label 卷标貌似在dumpe2fs中的第一个卷名。
2016.7.27.003 linux 设备文件 ls-l设备文件时，有两个数字，貌似是设备的代码，mknod是手动添加一个设备文件，用这两个数字来指代这个设备。
2016.7.27.004 linux hdparm -T测试cache存取功能，-t测试硬盘读写功能，对sata盘只有这个有用。
2016.7.27.005 linux /etc/fstab 文件的6个部分很重要，要牢记，第一栏，装置名称或者Label,卷标用dumpe2fs查阅，插槽的位置不同，系统产生的设备文件名不同，所以用设备文件名时，注意设备不要换插槽，如果使用卷标的话，设备可以换插槽，但是不要更改卷标，如果卷标改了，就找不到设备无法加载，第二栏，挂载点，挂载点一定是目录，（而且要存在吧？），第三栏，FS，第四栏，FS参数，牢记参数，sync/async这里应该是FS缓存吧，是非directIO/directIO,默认开启缓存，auto/noauto,当下达mount-a时是否自动挂载（这个指令什么时候下达？开机会自动下达吗？貌似是），ro/rw，如果设置为ro即使文件有写权限也不行，exec/noexec是否可执行，这里的执行是什么意思？是否针对目录？shell？bin?,user/nouser用户是否可挂在，suid/nosuid,这里的设置于前面的exec应该有关吧，如果不能执行，这个也没用阿，usrquota,grpquota前者是开启自动配额，后者是开启对群组的自动配额，两者有关系吧？default,async,auto,rw,exec,nouser,suid,dev(这是什么？），第五栏，是否dump备份，第六栏，是否开机fsck,主义mount-a是检测设置是否正确的方式。重申，如果配置错误，进入单人维护模式时/处于只读模式，此时需要mount -n -o remount,rw /
2016.7.27.006 linux 挂在IOS镜像 mount -o loop 镜像文件 挂载点
2016.7.27.007 linux 挂载一个大文件 先使用dd产生一个全为0的大文件，然后对文件进行创建FS，然后挂载，创建FS后快大小还是4096而不是1M。
2016.7.27.008 linux 扩展swap空间 1，使用分区创建，使用fdisk创建分区，要修改system为82，默认linux为83，mkswap分区的设备文件，swapon设备文件，使用free可看，swapon -s查看分区信息。2，使用dd创建文件，然后mkswap，swapon,free
2016.7.27.009 linux 启动扇区和超级块 超级块的大小为1024字节，超级块的前面需要保留1024字节用于安装开机管理程序，那前面的1024字节是启动扇区吗？开机管理程序是安装在启动扇区的吗？难道启动扇区不止一个扇区？按照书上的理解，如果FS块大于2048的时候，块0中包含启动扇区和超级块，但是这里有疑问，每个FS都会有超级块，但是启动扇区应该是在磁盘开头处吧？就是说这里的块0应该没有启动扇区吧。还有一个理解就是开机管理程序在启动扇区中，具有开机管理程序的启动扇区是开头的启动扇区，别的分区中也有启动扇区，但是里面没有开机管理程序。
2016.7.27.010 linux parted 使用parted /dev/sda print结合fdisk -l查看。
2016.7.27.011 linux 挂在新盘 fdisk,mkfs -t ext3 /dev/XX,mount,修改/etc/fstab,其中有default 1 2,不要忘记修改后用mount -a测试
2016.7.27.012 linux 压缩打包 目的是下载大型文件
2016.7.27.013 linux 压缩 gzip-d,解压缩，-c输出到屏幕可以重定向，-v，显示压缩比，-t，测试，-1最快，-9压缩比最高，查看压缩文件用zcat,bzip2,-k保留源文件，-z压缩参数？tar [-j(bzip2压缩)/-z(gzip压缩)][c(建立)/t(查看)/x(解压)][v(过程显示)][-f(要被处理的文件名)]:tar -jcv -f filename.tar.bzip2 要处理的文件或者目录(对文件或者目录进行打包压缩);tar -jtv -f filename.tar.bzip2(查看文件);tar -jxv -f filename.tar.bzip2(对文件进行解压拆包)。
2016.7.29.001 linux 压缩打包 为防止在解压缩时，由于压缩包内的目录是绝对目录，导致将原OS上的相同的目录（肯定会有）进行覆盖的情况，打包默认将根目录去除，使用-P可以将根目录带上，-p是保存源文件，目录的属性，不会在解压时变成当前用户的属性，一般解压时会在当前路径下解压，使用-C可以指定路径，打包的目录可以有多个，使用空格隔开，--exclude选项也可以多个，使用空格隔开，--newer-mtime,--newer="2008/09/29" /etc/*,这个--newer要借鉴。-tar -cvf - /etc | tar -xvf -,使用管线命令一边打包一边解压，注意这个-,指代文件，在建立打包压缩文件时，可以通过指定文件的目录来使得该文件在哪个目录下生成。
2016.7.29.002 linux dump dump对备份整个文件系统，很有用，可以指定备份级别，这里0是全备，其余备份level值如何确定还不知道。如果备份的是文件系统中的文件，则无法指定备份级别。dump -S显示的是备份目标需要多少byte的空间，例子，dump -0u -f /root/boot.dump /boot，/etc/dumpupdates仅有在dump完整文件系统时才会更新。dump -W查看的是/etc/fstab中需要dump的FS，貌似vfat没有显示，备份普通目录时，u,level都无法使用，可以用-j进行压缩，于tar相似，但是估计没有tar用的多吧。
2016.8.1.001 linux vi/vim 如果复制内容不是整行，则粘贴的时候p,P是以当前光标的前后进行粘贴，如果复制内容是整行，则p,P以光标的上一行和下一行进行定位粘贴,注意在操作文档时要看是否开着输入法，如果开着，像$这样的操作字符就失灵了。
2016.8.1.002 linux dd 直接磁盘之间的拷贝，这个命令是磁盘层面的，能将FS的超级块，MBR，boot sector等全部原样拷贝到另一个文件，使用这种方式能够制作一个一模一样的盘，用于备份。现在用于备份的指令应该有tar,dump,dd。
2016.8.1.003 linux cpio 又一个备份的指令，cpio -ovcB > [file|device],cpio -ivcdu < [file|device],cpio -ivct < [file|device]因为这个傻指令指挥将备份的内容打印在标准输出上，因此需要定向符号才行，find /boot |cpio -ocvB > /tmp/boot.cpio,/boot文件下img文件都是cpio后进行压缩的文件，先使用file /boot/..img查看，发现文件是gzip压缩文件，然后需要将文件重命名为...img.gz才可正常解压，如果直接解压会出错，然后最好现拷贝出来，然后重命名解压，最后从cpio -dcvdu < ..img最后西那是为多个目录的备份。
2016.8.1.004 linux 备份 bzip2压缩比更高，备份/srv/myproject分区，1，dump -0u -j -f /backups/myproject.dump /srv/myproject,注意，/srv/myproject是一个单独分区，单独FS，-j选项用于压缩，当原目录被修改时，使用dump -1u -j -f /backups/myproject.dump.1 /srv/myproject这是个增量备份，2，还原，将/srv/myproject卸载，格式化，umount /dev/hdc6,mkfs -t ext3 /dev/hdc 3,重新挂在，由于在/etc/fstab中，可以mount -a,进入该目录然后恢复,cd /srv/myproject,restore -r -f /backups/myproject.dump,restore -r -f /backuos/myproject.dump.1,书上说如果还有level2,level3时，需要依次恢复，从这里猜测，备份完level1的备份之后，是否后面只能用level2的备份，意思就是说，从全备开始，只能有9个增备，然后需要接着全备？
2016.8.2.001 基础 内核 内核提供一系列的API供应用程序去调用，应用程序使用API称为系统调用。进程不知道自己何时使用CPU，自己在内存中的位置，访问的文件到底在哪，不能与别的进程通信，不能产生新的进程，不能杀死自己，不能和外设通信。所有一切由内核来决定。内核有监控所有进程运行状态改变的数据结构，有文件名与磁盘物理位置的数据结构，有每个进程的虚拟内存与真实内存和磁盘交换区之间的映射关系（由此可以退出，对进程来说，只能看到自身的虚拟内存）。内核产生目中通信机制来使得进程之间通信。内核执行与外设的通信。综上所述，进程创建新进程、创建管道、与外设通信等等所有的机制都只是进程自身的一个请求，请求内核帮助实现。
2016.8.2.002 基础 shell shell只是一个进程
2016.8.2.003 基础 I/O 同一套IO模型可对所有文件进行操作，包括设备文件。应用程序发起IO请求，内核将其转换为FS操作或者设备驱动程序操作。IO系统调用理解为内核提供的进行IO的那一套函数。这套函数使用文件描述符来指代打开的文件，使用open()函数获得，0,1,2就是指标准输入文件，标准输出文件和错误输出文件的文件描述符。IO系统调用就是指内核提供的IO的函数。系统调用层就是内核提供的函数。
2016.8.2.004 基础 进程 进程是正在制定的程序实例，内核将程序载入虚拟内存，分配变量空间，建立进程相关信息的数据结构，每个进程的内存分成4部分，指令、数据、堆、栈，fork()是系统调用，进程使用系统调用请求内核创建新的子进程，子进程有自己的数据、堆栈副本（说明是不同的内存区域），共享程序（说明是同一内存区域），另外C语言提供的相关函数已经是在系统调用的基础上加工过了的，猜测。这里有个疑问，子进程可以去使用execve()系统调用去执行别的程序，但是执行别的程序会对与父进程共享的程序文本产生影响吗？书上说会销毁。当然自身的数据和堆栈副本可随便更改。_exit()是终止进程的系统调用，终止后会产生一个非负小整数，供父进程的wait()系统调用来识别。每个进程都有相关的UID和GID。进程间通信的机制有：信号，表示时间发生。管道，用于进程间传递数据，套接字，用于同一台主机或者是联网不同主机间进程通信，文件锁，消息队列，用于进程间交换信息，信号量，共享内存。进程需要获得CPU时才能做操作，因此给进程的信号需要挂起直到进程获得CPU才会送给进程。
2016.8.2.005 基础 线程 进程内的线程共享同一个虚拟内存，执行相同的程序代码，共享同一数据区域和堆，但是有不同的栈。栈是用来装在本地变量和链接信息的存储空间。线程之间通过全局变量就能够共享。其他进程间共享的机制也能给线程使用。
2016.8.2.006 基础 shell任务控制 shell执行的每个程序（每条指令）都会在一个新的进程内发起如ls -l | sort -k5n | less创建了3个进程，通过管道进行进程间通信。
2016.8.2.007 基础 客户端/服务器 客户端和服务器是两个进程，使用进程间的通信方式进行通信。
2016.8.2.008 基础 /proc /proc文件系统实现用户对系统属性的查看和修改。
2016.8.3.001 linux vim 光标移动到哪行，直接nG,n[Enter]是往下移动n行。另存为是w: 新文件，nx删除这一行中的第n个字符，ndd是删除哪一行。如果在打开vim后，使用［ctrl]+z,则在相同目录下出现.swp文件，用于恢复，这是手动打开的，如vim崩溃，应该是自动打开这个文件的。出现文件后，每次编辑时都有提示，需要删除才会没有提示。v用来选择字符，V用来选择行，［ctrl］+v现则方块区域。:sp在同一个窗口下打开两个，使用[ctrl]+w+箭头在窗口间转换。另外，set还有多个设置，主要有set nu显示行号。win于linux下文本共享要考虑dos2unix.编码转换iconv -f 原编码 -t 目标编码 filename [-o newfile]这里思考一个问题，应该没有检测编码的东西吧，至少系统上应该没有，因为看编码是不是对只能看出来之后的内容是否是乱码，但貌似乱码计算机是查不出来的，要靠人的认知才行吧？
2016.8.4.001 基础 系统调用 应用程序先调用C语言的外壳函数（glibc),外壳函数中存在终端的指令0X80,进入中断处理程序，此时进入内核态，中断处理程序完成系统调用，调用相应服务例程，获得结果返回中断程序，返回给外壳函数，外壳会将结果返回应用程序。因此调用系统调用，就是调用外壳函数，由外壳函数调用系统调用。（从这里的“调用系统调用”就能感觉到系统调用就是内核的API）
2016.8.4.002 基础 库函数 库函数是C语言函数库中的函数，有些会调用系统调用，有些不会，目的是提供比系统调用更加方便的函数功能。glibc就是GNU的C语言library.
2016.8.4.003 基础 文件IO 文件IO是一种系统调用。所有IO操作度使用fd，一个非负小整数来指代打开的文件，包括普通文件，管道，FIFO，scoket，终端。注意，每个进程，文件描述符自成一套。0,1,2在程序运行之前，有shell打开，并一直处于打开状态，各程序继承shell的副本，4个系统调用open(),read(),write(),close()可对所有类型文件进行IO操作。copy函数会调用这些系统调用，所以可以./copy a.txt /dev/tty,open()函数调用成功，则必须保证返回的fd为该进程中未使用的最小整数，open函数中的flag参数有个值O_ASYNC，如果设置了，当对open的fd进行IO操作时，系统产生一个信号通知进程，这一特性较信号驱动IO!!!!!,O_DIRECT,无系统缓冲的IO，O_DSYNC，根据同步IO数据完整性的完成要求来进行写操作。O_NONBLOCK非阻塞方式，O_SYNC同步IO。系统调用不会自动分配缓冲区，需要程序预先分配。
2016.8.5.001 基础 进程 每个进程都是由父进程产生，其实进程号为1，每个进程的内存布局有多个部分，称之为segment。1，文本段，包含进程运行的机器指令，只读，但可共享，2，初始化数据段3，未初始化的变量（貌似变量的初始化不是从文件中读取），内存中将初始化变量和未初始化变量分开存放。4，每个调用的函数分配一个栈，存放临时变量。5，堆。每个程序都有一个虚拟内存，内存中有这些东西，最后还有参数，和映射到虚拟内存的内核。每个程序（这里应该是可以执行的程序，就是已经是机器码的程序）都有一个固定的虚拟内存，就是说一个程序运行时在内存中就是需要这么一块固定格式的东西，含有各个部分。然后将这块东西分割成页的单元，部分放RAM中，部分放在SWAP中。这样一来，就相当于每个程序都在内存中，这个内存是RAM+SWAP。然后每个进程都有一张页表，记录那些页在哪个物理内存，或者磁盘上。虚拟内存管理使得每个进程之间相互隔离，又能通过某些方式将几个进程虚拟内存中的某部分（程序文件或者数据）映射到同一块物理内存中，达到程序共享或者进程间通信的目的。
2016.8.5.002 基础 栈 寄存器应该在cpu里面吧？对应栈有个专用的寄存器较栈指针，不知道是不是全局的，每调用一个函数，就会在栈顶新分配一帧，寄存器用于跟踪栈顶，每个进程使用一个栈，那栈顶寄存器应该是针对每一个进程的帧的。
2016.8.5.003 基础 内存分配 堆栈上的内存应该就是进程需要为某些数据结构分配的额外内存
2016.8.5.004 基础 /proc /proc中的文件貌似是实时查看相应的进程内容用的，有些是指向该进程下某些队形的软链接，理解为数据路的V$视图，但是部分可以修改
2016.8.5.005 基础 文件IO read(),write()系统调用不会直接操作磁盘文件，只在用户空间缓冲区和内核高速缓存之间复制数据。目前文件IO缓冲区位于页面高速缓存(这是哪块东西？)